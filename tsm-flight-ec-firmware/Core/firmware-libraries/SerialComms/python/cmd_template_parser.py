"""
Author: Marshall Stone (syzdup)

Description: 

Autogenerates 3 files (pack_cmd_defines.h, pack_cmd_defines.c, telem.c),
cmd_template_parser.py takes in three arguments:    --f "filename" 
                                                    --n "board number"
                                                    --o "output file directory"
Usage: 

python3 cmd_template_parser.py -f telem_cmd_template.csv -n 0 -o "../../../Src
"""
from os import path
import pandas as pd
import numpy as np
import argparse
import sys
import time

clb_packet_header_sz = 12

telem_c_user_begin_tag = "// USER CODE BEGIN - MODIFICATIONS OUTSIDE THIS SECTION WILL BE DELETED"
telem_c_user_end_tag = "// USER CODE END - MODIFICATIONS OUTSIDE THIS SECTION WILL BE DELETED"

autogen_label = "// Autogenerated by firmware-libraries/SerialComms/python/cmd_template_parser.py on " + time.ctime()

#writes a function to the c file
def function_writer(row_number, function_contents):
    #selects entire row (function along with all args and argtypes)
    function_name = functions.iloc[row_number]
    num_args = int(function_name[2])
    c_file.write("void " + function_name[1] + "(uint8_t* data, uint8_t* status){\n\n\t")
    col_num = 4
    data_num = 0
    for x in range(num_args):
        c_file.write(function_name[col_num] + " " + function_name[col_num - 1] + " = ")
        if function_name[col_num] == "uint8_t":
            try:
                c_file.write("(data[" + str(data_num)
                                + "])/" + str(int(function_name[col_num + 1]))
                                + ";\n\t")
                data_num += 1
            except ValueError:
                c_file.write("(data[" + str(data_num) + "])/" + "1;\n\t")
                data_num += 1
        elif function_name[col_num] == "uint16_t":
            try:
                c_file.write("(data[" + str(data_num + 1)
                                + "]<<8|data[" + str(data_num)
                                + "])/" + str(int(function_name[col_num + 1]))
                                + ";\n\t")
                data_num += 2
            except ValueError:
                c_file.write("(data[" + str(data_num + 1)
                            + "]<<8|data[" + str(data_num) + "])/" + "1;\n\t")
                data_num += 2
        elif function_name[col_num] == "uint32_t":
            try:
                c_file.write("(data[" + str(data_num + 3)
                                + "]<<24|data[" + str(data_num + 2)
                                + "]<<16|data[" + str(data_num + 1)
                                + "]<<8|data[" + str(data_num + 0) + "])/"
                                + str(int(function_name[col_num + 1])) + ";\n\t")
                data_num += 4
            except ValueError:
                c_file.write("(data[" + str(data_num + 3)
                                + "]<<24|data[" + str(data_num + 2)
                                + "]<<16|data[" + str(data_num + 1)
                                + "]<<8|data[" + str(data_num + 0)
                                + "])/" + "1;\n\t")
                data_num += 4
        elif function_name[col_num] == "float":
            try:
                c_file.write("(data[" + str(data_num + 3)
                                + "]<<24|data[" + str(data_num + 2)
                                + "]<<16|data[" + str(data_num + 1)
                                + "]<<8|data[" + str(data_num + 0) + "])/"
                                + str(float(function_name[col_num + 1])) + ";\n\t")
                data_num += 4
            except ValueError:
                c_file.write("(data[" + str(data_num + 3)
                                + "]<<24|data[" + str(data_num + 2)
                                + "]<<16|data[" + str(data_num + 1)
                                + "]<<8|data[" + str(data_num + 0)
                                + "])/" + "1.0;\n\t")
                data_num += 4
        elif function_name[col_num] == "double":
            try:
                c_file.write("(data[" + str(data_num + 7)
                                + "]<<56|data[" + str(data_num + 6)
                                + "]<<48|data[" + str(data_num + 5)
                                + "]<<40|data[" + str(data_num + 4)
                                + "]<<32|data[" + str(data_num + 3)
                                + "]<<24|data[" + str(data_num + 2)
                                + "]<<16|data[" + str(data_num + 1)
                                + "]<<8|data[" + str(data_num + 0) + "])/"
                                + str(float(function_name[col_num + 1])) + ";\n\t")
                data_num += 4
            except ValueError:
                c_file.write("(data[" + str(data_num + 7)
                                + "]<<56|data[" + str(data_num + 6)
                                + "]<<48|data[" + str(data_num + 5)
                                + "]<<40|data[" + str(data_num + 4)
                                + "]<<32|data[" + str(data_num + 3)
                                + "]<<24|data[" + str(data_num + 2)
                                + "]<<16|data[" + str(data_num + 1)
                                + "]<<8|data[" + str(data_num + 0) + "])/1.0;\n\t")
                data_num += 4
        else:
            try:
                c_file.write("(data[" + str(data_num) + "])/" + str(int(function_name[col_num + 1])) + ".0;\n\t")
                data_num += 1
            except ValueError:
                c_file.write("(data[" + str(data_num) + "])/" + "1;\n\t")
                data_num += 1

        col_num += 3
        
    # Add usergen tags and user definitions
    c_file.write("\n\t" + telem_c_user_begin_tag + "\n")

    if function_name[1] in function_contents.keys():
        c_file.write(function_contents[function_name[1]])
    else:
        c_file.write("\n")
    c_file.write("\t" + telem_c_user_end_tag + "\n\n}\n\n")

def computeExpectedFunctionSize(functions, function_point):
    num_args    = int(functions["nums args"][function_point])
    function_sz = clb_packet_header_sz
    for i in range(num_args):
        arg_col = "arg_type" + str(i)
        arg_type = functions[arg_col][function_point]
        if arg_type == "uint32_t" or arg_type == "int32_t" or arg_type == "float":
            function_sz += 4
        elif arg_type == "uint8_t" or arg_type == "int8_t":
            function_sz += 1
        elif arg_type == "uint16_t" or arg_type == "int16_t":
            function_sz += 2
        elif arg_type == "double":
            function_sz += 8

    return function_sz


#argument parsing
parser = argparse.ArgumentParser(
    description="Command Template Parser Script"
)

parser.add_argument('-f', '--file_name', help="CSV Filename", type=str)
parser.add_argument('-n', '--board_num', help="Board number", type=str)
parser.add_argument('-o', '--output_dir', help="Output Directory", type=str)

args = parser.parse_args()
file_name = args.file_name
board_num = args.board_num
output_dir= args.output_dir

command_map = []
command_sz = []

# Create a remapping array for function calls, first 8 commands ID's are not used at this time
for i in range(0, 8): 
    command_map.append(-1)
    command_sz.append(-1)




try:
    functions = pd.read_csv(file_name)
except FileNotFoundError:
    print("Input file not found. Exiting now.")
    sys.exit()

#looks for keyword user and reads to end of file (FOR H FILE MAIN)
user_generated_code_h = ""  
line_num_h = 0 
try:
    with open("../../../Inc/pack_cmd_defines.h", 'r') as h_file:
        file_read = h_file.readlines()
        for line in file_read:
            line_num_h += 1
            if "user" in line:
                user_generated_code_h = file_read[line_num_h-1:]
except FileNotFoundError:
    pass

#write to header file
with open("../../../Inc/pack_cmd_defines.h", 'w') as header_file:

    #grab list of function names from csv
    function_names = functions['function_name']
    function_num = str(function_names.count())
    
    header_file.write(autogen_label + "\n\n")
    #defines and includes and stuff for beginning of h file go here
    header_file.write("#ifndef PACK_CMD_DEFINES_H\n#define PACK_CMD_DEFINES_H\n#define NUM_CMD_ITEMS " + 
                      function_num + "\n#define COMMAND_MAP_SZ " + str(int(function_num)+8) + "\n#include <stdint.h>\n\n")


    #for each function name in file, write out a function definition
    board_supported = functions['supported_target_addr']
    function_point = 0
    supported_functions = 0
    function_expected_sz = 0 # default expected size of function to just header
    for name in function_names:
        if str(board_num) in str(board_supported[function_point]):
            try:
                header_file.write("void " + name + "(uint8_t* data, uint8_t* status);\n\n")
                command_map.append(supported_functions)
                function_expected_sz = computeExpectedFunctionSize(functions, function_point)
                command_sz.append(function_expected_sz)
                supported_functions += 1
            except TypeError:
                #skips over nan values 
                pass
        else:
            command_map.append(-1)
            command_sz.append(-1)

        function_point += 1

    header_file.write("typedef void (*Cmd_Pointer)(uint8_t* x, uint8_t* y);\n\n")
    header_file.write("int16_t command_map[COMMAND_MAP_SZ];\n\n")
    header_file.write("int16_t command_sz[COMMAND_MAP_SZ];\n\n")
    header_file.write("Cmd_Pointer cmds_ptr[NUM_CMD_ITEMS];\n\n")
    header_file.write("// Note: to call a function do\n/**\n* (*cmds_ptr[0])(array ptr here)\n"
                      "*\n* The actual cmd functions will be defined in a separate c file by the firwmare\n"
                      "* developer for each board. They simply need to include this header file\n* in the c" 
                      "file in which they define the function. This allows the developer\n* to import/use any"
                      " variables or typedefs from the hal library. This file is\n* simply the jumptable that"
                      " gives the comms library an easy way to call\n*" 
                      " custom functions without additional knowledge of where this file is defined\n*\n*/")

    #write closing bracket and endif to file
    header_file.write("\n\n\n#endif\n")

    #write user generated code to h file
    line_index_h = 0
    for line in user_generated_code_h:
        header_file.write(user_generated_code_h[line_index_h])
        line_index_h += 1
    print("Finished generating pack_cmd_defines.h...")



#check for user code in pointer file
user_generated_code_pointer = ""  
line_num_pointer = 0 
try:
    with open("../../../Src/pack_cmd_defines.c", 'r') as pointer_file:
        file_read_pointer = pointer_file.readlines()
        for line in file_read_pointer:
            line_num_pointer += 1
            if "user" in line:
                user_generated_code_pointer = file_read_pointer[line_num_pointer-1:]
except FileNotFoundError:
    pass

#write to pointer file
with open("../../../Src/pack_cmd_defines.c", 'w+') as header_c_test:
    header_c_test.write(autogen_label + "\n\n")
    header_c_test.write("#include \"pack_cmd_defines.h\"\n")
    header_c_test.write("Cmd_Pointer cmds_ptr[NUM_CMD_ITEMS] = {\n\n")
    function_name_index = 0
    board_supported = functions['supported_target_addr']
    for  name in function_names:
        #fix check for board support 
        if str(board_num) in str(board_supported[function_name_index]):
            try:
                if int(function_names.count()-1) != int(function_name_index):
                    header_c_test.write(name + ",\n")
                else:
                    header_c_test.write(name + "\n")
        
            except TypeError:
                #skips over nan values
                pass
        function_name_index += 1
    header_c_test.write("};\n\n")

    ## Writing Command Remap Array
    header_c_test.write("int16_t command_map[COMMAND_MAP_SZ] = {")
    for i in range(0, function_point + 8):
        header_c_test.write(str(command_map[i]))
        if i != function_point + 7:
            header_c_test.write(", ")

    header_c_test.write("};\n")
    # header_c_test.write("uint16_t command_map_sz = " + str(len(command_map)) + ";\n\n")

    ## Writing Command Size Check Array
    header_c_test.write("int16_t command_sz[COMMAND_MAP_SZ] = {")
    for i in range(0, function_point + 8):
        header_c_test.write(str(command_sz[i]))
        if i != function_point + 7:
            header_c_test.write(", ")

    header_c_test.write("};\n")

    #write user gen code to pointer file
    line_index_pointer = 0
    for line in user_generated_code_pointer:
        header_c_test.write(user_generated_code_pointer[line_index_pointer])
        line_index_pointer += 1
    print("Finished generating pack_cmd_defines.c...")

# Store all user-written function definition sections of telem.c
user_generated_code = ""
function_names = list()  # Not sure if I'll need this
function_contents = dict()  # Maps function names to their user definitions
telem_c_main_user_code = ""   # User section at top of file
try:
    with open(path.join(output_dir, 'telem.c'), 'r') as c_file:
        file_read = c_file.readlines()

        # Using a while loop here since I want to move line_num ahead inside the loop
        line_num = 0
        while line_num < len(file_read):
            try:
                #First grab the user section at the top
                if file_read[line_num].strip() == telem_c_user_begin_tag:
                    line_num += 1
                    while file_read[line_num].strip() != telem_c_user_end_tag:
                        telem_c_main_user_code += file_read[line_num]
                        line_num += 1

                # Always will be in format "void function_name(args here)"
                # Slice from start of second word to right before first parentheses
                if len(file_read[line_num]) >= 4 and file_read[line_num][0:4] == "void":
                    start_index = 5
                    paren_index = file_read[line_num].find("(")
                    cur_function = file_read[line_num][start_index:paren_index]  # Extract function name
                    function_names.append(cur_function)

                    no_begin_tag = False  # For compatibility with telem.c's that don't have tags
                    while file_read[line_num].strip() != telem_c_user_begin_tag:
                        if file_read[line_num] == "}\n":  # If there's no user begin code tag
                            function_contents[cur_function] = "\n"
                            no_begin_tag = True
                            print(str(cur_function) + " does not have a properly defined user section. Creating empty one...")
                            break
                        line_num += 1
                    line_num  += 1  # Start reading 1 line after tag

                    if (not no_begin_tag):
                        # Read in the user definition
                        function_contents[cur_function] = ""
                        while file_read[line_num].strip() != telem_c_user_end_tag:
                            if file_read[line_num] == "}\n":  # Check if the end tag got deleted
                                break

                            function_contents[cur_function] += file_read[line_num]
                            line_num += 1

                        if function_contents[cur_function] == "":
                            function_contents[cur_function] += "\n"
            except Exception as e:
                print("Error when trying to read line number " + str(line_num) + " of telem.c")
                print(e)
            line_num += 1
except FileNotFoundError:
    print("Creating new telem.c file in output directory...")
    pass

#write out c file template
with open(output_dir+"/telem.c", 'w') as c_file:
    board_supported = functions['supported_target_addr']
    
    #write functions from csv file to c_file
    c_file.write(autogen_label + "\n\n")
    c_file.write("#include <stdint.h>\n\n")
    # Add user section at top of file back in
    c_file.write(telem_c_user_begin_tag + "\n")
    if telem_c_main_user_code != "":
        c_file.write(telem_c_main_user_code)
    else:
        c_file.write("\n")
    c_file.write(telem_c_user_end_tag + "\n\n")
    # Generate the functions, keeping their existing user definitions
    for x in range(int(function_num)):
        if board_num in str(board_supported[x]):
            function_writer(x, function_contents)

    print("Finished generating telem.c...\n")
