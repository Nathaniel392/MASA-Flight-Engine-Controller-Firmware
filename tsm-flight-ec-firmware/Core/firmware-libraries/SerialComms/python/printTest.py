import time
import sys
import json
import pandas as pd 
import numpy as np 
import file_generator_byte_info as byte_info



def main():

  

    # Script should read in from a csv and store the data
    calibration_parameters = pd.read_csv("calibration_data_flightec.csv", encoding= 'unicode_escape')
    # Eeach of the cols is now stored in a pandas data structure and can be accessed


    # Autogeneration label and timestamp - comments not included in some because they're put into C and python files
    begin_autogen_tag = "BEGIN AUTOGENERATED SECTION - MODIFICATIONS TO THIS CODE WILL BE OVERWRITTEN\n"
    autogen_label = "Autogenerated by firmware-libraries/SerialComms/python/calibration_file_generator.py on " + time.ctime()
    end_autogen_tag_c = "/// END AUTOGENERATED SECTION - USER CODE GOES BELOW THIS LINE\n"

    

    # For pack_callibration_defines.h
    pack_calibration_defines_h_string = "/// " + begin_autogen_tag + "\n/// pack_calibration_defines.h\n" + \
                                "/// " + autogen_label + "\n\n" + \
                                "#include \"calibrations.h\"\n" + \
                                "#include <stdint.h>\n\n"

    # For pack_callibration_defines.c
    pack_calibration_defines_c_string = "/// " + begin_autogen_tag + "\n/// pack_calibration_defines.c\n" + \
                                "/// " + autogen_label + "\n\n" + \
                                "#include \"pack_calibration_defines.h\"\n\nvoid pack_calibration_data(uint8_t* dst){\n"

    # Begin iterative process to step through the rows of the csv:
    
    packet_byte_length = 0  # Total bytes in packet (running total)

    for i in range(len(calibration_parameters.index)):
        
        # Only read the marked rows
        should_generate = calibration_parameters['should_generate'][i]

        # Error checking section, make sure it is written properly
        # Only write the value to pack_calibration_defines.h if should_generate is 'y'
        try:
            assert(should_generate == 'y' or should_generate == 'n')
        except:
            error_ocurred = True
            print("[row " + i + "] " + "Error: should_generate can only be 'y' or 'n'")
            
        # Can I delete this???????????
        if (should_generate != 'y'):
            continue

        if(should_generate == 'y'):

            # Error Checking: Check the type cast to be valid
            # Define type_cast var for this row:
            type_cast = calibration_parameters['type_cast'][i]
            try:
                assert type_cast in byte_info.type_byte_lengths.keys()
            except:
                error_ocurred = True
                print("[row " + i + "] " + "Invalid type cast. Valid Types are:\n" + str(type_byte_lengths.keys()))


            # Increment the calibration byte count
            byte_length = byte_info.type_byte_lengths[type_cast]
            packet_byte_length += byte_length

             # Split the variable into byte-sized CALIBRATION_ITEMs and add them to the #defines list in pack_calibration_defines.h
             # Needs to be in the format of:
             # One line for each byte in the total number of bytes for the variable (byte_length number of bytes)
             # #define	CALIBRATION_ITEM_0	((uint32_t) (valve_states*1)) >> 0 
             #          define the item       cast type  firmware variable    ????
             #          w/ number as the                 name * the scalar
             #          unique identifier                factor to convert
             #                                           float to int while
             #                                           maintaining precision


            for b in range(0, byte_length):
                pack_calibration_defines_h_string += "#define\tCALIBRATION_ITEM_" + str(packet_byte_length - byte_length + b) + \
                "\t((" + type_cast + ") (" + str(firmware_variable) + "*" + str(xmit_scale) + ")) >> " + str(8*b) + " \n"


            # We have defined all the items, now we need to list the number of total items and give docs
            # Add the number of CALIBRATION_ITEMs to pack_calibration_defines, and declare pack_calibration_data() and generate its documentation
            pack_calibration_defines_h_string += "#define\tCLB_NUM_CALIBRATION_ITEMS\t" + str(packet_byte_length) + "\n"
            pack_calibration_defines_h_string += "\n/**\n * Takes in a uint8_t array of size CLB_NUM_CALIBRATION_ITEMS and packs the " \
                + "\n * global variables into it as defined in pack_calibration_defines.h\n *\n * @param dst\t<uint8_t*>\tArray to " \
                + "write the global variables to after packing their bytes for calibrations.\n**/\nextern void pack_calibration_data(uint8_t* dst);\n"



            # Fill up pack_calibration_defines.c with unpacking code

            # Follows the format:
            # *(dst + 0) = CALIBRATION_ITEM_0;
            # cast to pointer
            # 0 or the number is the unique identifier
            
            # We define this for each byte in the packet essentially, so we do it packet_bye_length times

            # Need to create an instance in the .c file for each variable defined in the .h file
            
            for m in range(0, packet_byte_length):
                pack_calibration_defines_c_string += "\t*(dst + " + str(m) + ") = CALIBRATION_ITEM_" + str(m) + ";\n"
            pack_calibration_defines_c_string += "}"


            """ Writing to files """

            # ?????? Does anything else need to be written to files?

            try:
                pack_calibration_defines_h = open("../../../Inc/pack_calibration_defines.h", "w+")  # Generates file in project folder
                pack_calibration_defines_c = open("../../../Src/pack_calibration_defines.c", "w+")
            except:
                print("Creating new pack files...\n")


            pack_calibration_defines_h.write(pack_calibration_defines_h_string)
            pack_calibration_defines_c.write(pack_calibration_defines_c_string)

            # Close all files
            pack_calibration_defines_h.close()
            pack_calibration_defines_c.close()


            if not error_ocurred:
            print(filename + " Successfully Parsed!")
            print(" --- Packet statistics --- ")
            print("Packet items: " + str(num_items))
            print("Packet length (bytes): " + str(packet_byte_length))
            print("\nCreated/updated 5 files:\n"+ output_file + \
                        "\n../src/pack_calibration_defines.h" + \
                        "\n../src/pack_calibration_defines.c\n" + \
                        output_globals_h_file + "\n" + output_globals_c_file + "\n")
            else:
                print("\nScript failed to complete. One or more errors occurred. See command line or terminal interface for "
                    "details.\n")

if __name__ == '__main__':
    main()

    