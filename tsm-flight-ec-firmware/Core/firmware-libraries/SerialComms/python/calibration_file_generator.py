"""
MASA callibration format and global variables generator script

Michigan Aeronautical Science Association
Authors: Sidharth Anantha (ananthas@umich.edu)
Modified from telem_file_generator.py
Created: July 25, 2021
"""

import time
import sys
import json
import pandas as pd 
import numpy as np 
import file_generator_byte_info as byte_info


"""
Main program
Reads in the calibration data .csv template and generates packet decoding .py

REQUIREMENTS:
    1. First command line arg is the input csv file which is required
    2. Second command line arg is optional and is the output py file
        If no second arg is provided, the file will default to ./calibrationParse.py
    3. Third command line arg is optional and is the output header file
        If no third arg is provided, the file will default to ../inc/globals.h
    3. Fourth command line arg is optional and is the output c file
        If no fourth arg is provided, the file will default to ../inc/globals.c
"""


def main():

    # error_ocurred variable will be used to avoid the program print out that it was
    # successful without having to terminate the program when the first error ocurrs
    error_ocurred = False

    # Load in json file that contains the addresses of the boards
    with open('./board_addr.txt') as board_addr_files:
        board_addresses = json.load(board_addr_files)

    CAL_TEMPLATE_FILE_ARG_NUM = 1
    PARSER_FILE_OUTPUT_ARG_NUM = 2
    BOARD_ADDR_ARG_NUM = 3

    # Open the calibration template file
    filename = sys.argv[CAL_TEMPLATE_FILE_ARG_NUM]
    print("Reading " + filename + "...")

    # Script should read in from a csv and store the data
    # File to read in: "calibration_data_flightec.csv"
    calibration_parameters = pd.read_csv(filename, encoding= 'unicode_escape')
    # Eeach of the cols is now stored in a pandas data structure and can be accessed
    
    # Note: You can also hardcode the file with this:
    # calibration_parameters = pd.read_csv("calibration_data_flightec.csv", encoding= 'unicode_escape')

    output_file_parser_name = board_addresses[sys.argv[BOARD_ADDR_ARG_NUM]] + "Calibrations"
    output_file = sys.argv[PARSER_FILE_OUTPUT_ARG_NUM]
    
    '''
    DO I NEED THIS??
    if len(sys.argv) > 2:
        if sys.argv[2][-3:] == ".py":
            output_file = sys.argv[2]
    else:
        sys.exit("Second command line arg must be a py file.")
    '''

    # Autogeneration label and timestamp - comments not included in some because they're put into C and python files
    begin_autogen_tag = "BEGIN AUTOGENERATED SECTION - MODIFICATIONS TO THIS CODE WILL BE OVERWRITTEN\n"
    autogen_label = "Autogenerated by firmware-libraries/SerialComms/python/calibration_file_generator.py on " + time.ctime()
    end_autogen_tag_c = "/// END AUTOGENERATED SECTION - USER CODE GOES BELOW THIS LINE\n"

    
    # Fill out basic headers for the .h and .c files:

    # For pack_callibration_defines.h
    pack_calibration_defines_h_string = "/// " + begin_autogen_tag + "\n/// pack_calibration_defines.h\n" + \
                                "/// " + autogen_label + "\n\n" + \
                                "#ifndef PACK_CALIBRATION_DEFINES_H\n#define PACK_CALIBRATION_DEFINES_H\n\n" + \
                                "#include \"calibrations.h\"\n" + \
                                "#include <stdint.h>\n\n"

    # For pack_callibration_defines.c
    pack_calibration_defines_c_string = "/// " + begin_autogen_tag + "\n/// pack_calibration_defines.c\n" + \
                                "/// " + autogen_label + "\n\n" + \
                                "#include \"pack_calibration_defines.h\"\n\nvoid pack_calibration_data(uint8_t* dst){\n"


    # Hardcoded packet header for parse_packet function
    packet_header_byte_size = 12
    parser_dict_header_str = "\t\tself.dict[self.items[0]] = int((float(struct.unpack(\"<B\", packet[0:1])[0]))/1)\n" \
                             "\t\tself.dict[self.items[1]] = int((float(struct.unpack(\"<B\", packet[1:2])[0]))/1)\n" \
                             "\t\tself.dict[self.items[2]] = int((float(struct.unpack(\"<B\", packet[2:3])[0]))/1)\n" \
                             "\t\tself.dict[self.items[3]] = int((float(struct.unpack(\"<B\", packet[3:4])[0]))/1)\n" \
                             "\t\tself.dict[self.items[4]] = int((float(struct.unpack(\"<B\", packet[4:5])[0]))/1)\n" \
                             "\t\tself.dict[self.items[5]] = int((float(struct.unpack(\"<B\", packet[5:6])[0]))/1)\n" \
                             "\t\tself.dict[self.items[6]] = int((float(struct.unpack(\"<H\", packet[6:8])[0]))/1)\n" \
                             "\t\tself.dict[self.items[7]] = int((float(struct.unpack(\"<I\", packet[8:12])[0]))/1)\n"

    # For calibration_parser.py
    # Starts off the parser data with the hard coded packet header
    parser_data_dict_str = parser_dict_header_str
    parser_units_dict_str =  "\n\t\tself.units[self.items[0]] = \"ul\"\n" \
                             "\t\tself.units[self.items[1]] = \"ul\"\n" \
                             "\t\tself.units[self.items[2]] = \"ul\"\n" \
                             "\t\tself.units[self.items[3]] = \"ul\"\n" \
                             "\t\tself.units[self.items[4]] = \"ul\"\n" \
                             "\t\tself.units[self.items[5]] = \"ul\"\n" \
                             "\t\tself.units[self.items[6]] = \"ul\"\n" \
                             "\t\tself.units[self.items[7]] = \"ul\"\n"
    parser_self_init_str = ""
    parser_items_list = list()


    # Begin iterative process to step through the rows of the csv:
    
    packet_byte_length = 0  # Total bytes in packet (running total)

    # num_items begins at 8 to account for the hardcoded packet header
    # num_items is used as an index to keep track of items in the parser
    num_items = 8  # Doesn't use enumerate to get the number of items because not all lines get calibration'd (should_generate column)
    
    ### !!!! I'M NOT SURE THIS SHOULD BE SET TO 8, I THINK IT MIGHT BE 0, ASK NATHA AND CHECK

    for i in range(len(calibration_parameters.index)):
        
        # Only read the marked rows
        should_generate = calibration_parameters['should_generate'][i]

        # Error checking section, make sure it is written properly
        # Only write the value to pack_calibration_defines.h if should_generate is 'y'
        try:
            assert(should_generate == 'y' or should_generate == 'n')
        except:
            error_ocurred = True
            print("[row " + i + "] " + "Error: should_generate can only be 'y' or 'n'")
            
        # Can I delete this???????????
        if (should_generate != 'y'):
            continue

        if(should_generate == 'y'):

            # Error Checking: Check the type cast to be valid
            # Define type_cast var for this row:
            type_cast = calibration_parameters['type_cast'][i]
            try:
                assert type_cast in byte_info.type_byte_lengths.keys()
            except:
                error_ocurred = True
                print("[row " + i + "] " + "Invalid type cast. Valid Types are:\n" + str(type_byte_lengths.keys()))


            # Increment the calibration byte count
            byte_length = byte_info.type_byte_lengths[type_cast]
            packet_byte_length += byte_length

             # Split the variable into byte-sized CALIBRATION_ITEMs and add them to the #defines list in pack_calibration_defines.h
             # Needs to be in the format of:
             # One line for each byte in the total number of bytes for the variable (byte_length number of bytes)
             # #define	CALIBRATION_ITEM_0	((uint32_t) (valve_states*1)) >> 0 
             #          define the item       cast type  firmware variable    ????
             #          w/ number as the                 name * the scalar
             #          unique identifier                factor to convert
             #                                           float to int while
             #                                           maintaining precision


            firmware_variable = calibration_parameters['firmware_variable'][i]
            xmit_scale = calibration_parameters['xmit_scale'][i]



            for b in range(0, byte_length):
                pack_calibration_defines_h_string += "#define\tCALIBRATION_ITEM_" + str(packet_byte_length - byte_length + b) + \
                "\t((" + type_cast + ") (" + str(firmware_variable) + "*" + str(xmit_scale) + ")) >> " + str(8*b) + " \n"



        # Update the calibration_parser.py strings           

        python_variable = firmware_variable

        
        python_type = calibration_parameters['python_type'][i]
        
        
        unit = calibration_parameters['unit'][i]

        parser_items_list.append(python_variable)

        parser_data_dict_str +=	"\t\tself.dict[self.items[" + str(num_items) + "]] = " + python_type + \
                            "((float(struct.unpack(" + byte_info.type_unpack_arg[type_cast] + ", packet[" + \
                            str(packet_byte_length + packet_header_byte_size - byte_length) + ":" + \
                            str(packet_byte_length + packet_header_byte_size) + "])[0]))/" + str(xmit_scale) + ")\n"
        
        parser_units_dict_str += "\t\tself.units[self.items[" + str(num_items) + "]] = \"" + unit + "\"\n"
        
        num_items += 1

    
    # Now we exit the forloop, as we have completed writing variables to the string
    



    # We have defined all the items, in our h file, now we need to list the number of total items and give docs
    # Add the number of CALIBRATION_ITEMs to pack_calibration_defines, and declare pack_calibration_data() and generate its documentation
    pack_calibration_defines_h_string += "#define\tCLB_NUM_CALIBRATION_ITEMS\t" + str(packet_byte_length) + "\n"
    pack_calibration_defines_h_string += "\n/**\n * Takes in a uint8_t array of size CLB_NUM_CALIBRATION_ITEMS and packs the " \
        + "\n * global variables into it as defined in pack_calibration_defines.h\n *\n * @param dst\t<uint8_t*>\tArray to " \
        + "write the global variables to after packing their bytes for calibrations.\n**/\nextern void pack_calibration_data(uint8_t* dst);\n\n" \
        + "#endif\n"




    # Now that we have defined everything in the .h file, we can now populate the .c file

    # Fill up pack_calibration_defines.c with unpacking code

    # Follows the format:
    # *(dst + 0) = CALIBRATION_ITEM_0;
    # cast to pointer
    # 0 or the number is the unique identifier
    
    # We define this for each byte in the packet essentially, so we do it packet_bye_length times

    # Need to create an instance in the .c file for each variable defined in the .h file
    
    for m in range(0, packet_byte_length):
        pack_calibration_defines_c_string += "\t*(dst + " + str(m) + ") = CALIBRATION_ITEM_" + str(m) + ";\n"
    pack_calibration_defines_c_string += "}"


    # Updating calibration_parser.py strings
    # !!! ARE THESE FIELDS CORRECT?
    parser_self_init_str += "\t\tself.num_items = " + str(num_items) + "\n" + \
                            "\t\t\n" + \
                            "\t\tself.dict = {}\n" + \
                            "\t\tself.units = {}\n" + \
                            "\t\t\n" + \
                            "\t\tself.items = [''] * self.num_items\n" \
                            "\t\tself.items[0] = 'packet_type'\n" \
                            "\t\tself.items[1] = 'origin_addr'\n" \
                            "\t\tself.items[2] = 'target_addr'\n" \
                            "\t\tself.items[3] = 'priority'\n" \
                            "\t\tself.items[4] = 'num_packets'\n" \
                            "\t\tself.items[5] = 'do_cobbs'\n" \
                            "\t\tself.items[6] = 'checksum'\n" \
                            "\t\tself.items[7] = 'timestamp'\n" \
                            # End Hardcoded packet header

    # Add the initialization for the items dict to the calibration parser
    # Index has a "+ 8" to account for the first 8 parts of items which is the
    #   hardcoded packet header
    for index, var in enumerate(parser_items_list):
        parser_self_init_str += "\t\tself.items[" + str(index + 8) + "] = \'" + var + "\' \n"

    # Append the units dictionary to the self init str
    parser_self_init_str += parser_units_dict_str

    # Now we will write this string to the file.

    """ Writing to files """

    # Open the parser files:

    calibration_parser = open(output_file, "w+")
    
    #!!!!! Temporary, this is only code used for testing. delete after!
    with open("../../../Inc/pack_calibration_defines.h", "w+") as pack_calibration_defines_h:
        pack_calibration_defines_h.write(pack_calibration_defines_h_string)
    
    with open("../../../Src/pack_calibration_defines.c", "w+") as pack_calibration_defines_c:
        pack_calibration_defines_c.write(pack_calibration_defines_c_string)



    # Write to parser files:

    calibration_parser.write(	"### " + begin_autogen_tag + "\n### calibrationParse.py\n" + "### " + autogen_label + \
                    "\n\nimport time\nimport struct\n\nclass " + output_file_parser_name +":\n\n" + \
                    "\tdef __init__(self):\n" + \
                    "\t\tself.packet_byte_size = " + \
                    str(packet_byte_length + packet_header_byte_size) + "\n" + \
                        parser_self_init_str + "\n"
                    "\tdef parse_packet(self, packet):\n" + \
                    parser_data_dict_str)


    # This is the correct code that needs to be implemented:
    '''
    with open("../../../Inc/pack_calibration_defines.h", "w+") as pack_calibration_defines_h:
        pack_calibration_defines_h.write(pack_calibration_defines_h_string)
    
    with open("../../../Src/pack_calibration_defines.c", "w+") as pack_calibration_defines_c:
        pack_calibration_defines_c.write(pack_calibration_defines_c_string)
    '''

    # Close all files
    # Don't need to explicitly call, implicitly called with with statement.
    # pack_calibration_defines_h.close()
    # pack_calibration_defines_c.close()
    calibration_parser.close()

    print("hi")
    if not error_ocurred:
        print(filename + " Successfully Parsed!")
        print(" --- Packet statistics --- ")
        print("Packet items: " + str(packet_byte_length/8))
        print("Packet length (bytes): " + str(packet_byte_length))
        print("\nCreated/updated 2 files:\n"+ \
                    "\n../src/pack_calibration_defines.h" + \
                    "\n../src/pack_calibration_defines.c\n" + "\n")
    else:
        print("\nScript failed to complete. One or more errors occurred. See command line or terminal interface for "
            "details.\n")

if __name__ == '__main__':
    main()
