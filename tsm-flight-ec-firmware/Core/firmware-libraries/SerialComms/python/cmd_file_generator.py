"""
MASA firmware-side command handling C code generation script

Michigan Aeronautical Science Association
Author: Nathaniel Kalantar (nkalan@umich.edu)
Created: December 18, 2020
Updated: January 2, 2021
"""

import file_generator_byte_info as byte_info
import csv
import sys
import time


"""
Main program
Reads in the .csv template and generates files from it

Takes the following command line arguments:
    python(3) cmd_file_generator.py <cmd template csv> <gui/Python/ directory>
"""
def main():
    
    # Autogeneration label and timestamp
    begin_autogen_tag = "### BEGIN AUTOGENERATED SECTION - MODIFICATIONS TO THIS CODE WILL BE OVERWRITTEN\n"
    end_autogen_tag = "### END AUTOGENERATED SECTION - USER CODE GOES BELOW THIS LINE\n"
    autogen_label = "### Autogenerated by firmware-libraries/SerialComms/python/cmd_file_generator.py on " + time.ctime()

    cmd_args = dict()  # Key is packet_type (int), value is a list of tuples for (argname, argtype, xmit_scale)
    cmd_id_to_name = dict()  # Key is packet_type (int), value is the function name associated with that packet_type, used to write comments in s2_command()


    """
    Read the csv template file and store information about the commands and their arguments
    """

    # Open the telem template file
    filename = sys.argv[1]

    # Determine the directory to generate the file into (should be the gui/Python directory)
    try:
        filepath = sys.argv[2]
        assert(filepath != "")
    except:
        filepath = "./"
    
    if filepath[len(filepath)-1] != "/":
        filepath += "/"
    
    try:
        with open(filename, newline='') as template_file:
            print("Reading " + filename + "...")
            csvread = csv.reader(template_file)  # csv.reader objects work with iterators and are not indexable

            # Create a dictionary mapping column names to column indices from the first row
            col = dict()
            for colnum, colname in enumerate(csvread.__next__()):
                col[colname] = colnum

            # Starts reading from second row. line is a list of strings
            csv_row_num = 2  # Track the row number for error checking
            for line in csvread:

                # Parse the row and grab the variables
                packet_type             = int(line[col["packet_type"]])
                function_name           = line[col["function_name"]]
                num_args                = int(line[col["nums args"]])            
                supported_target_addr   = line[col["supported_target_addr"]]  # Note: this will be defined in a separate file in the future
                description             = line[col["description"]]  # Only for the gui, not used in firmware (I think)

                # Update the command name dictionary
                cmd_id_to_name[packet_type] = function_name

                # Insert the function argument info into the proper list in the dictionary
                cmd_args[packet_type] = list()

                # Args are grouped in columns of 3, starting at the column immediately after nums args (see template for example)
                for n in range(num_args):
                    arg_name = line[col["nums args"] + 3*n + 1]
                    arg_type = line[col["nums args"] + 3*n + 2]
                    try:  # default xmit_scale is 1
                        xmit_scale = int(line[col["nums args"] + 3*n + 3])
                    except:
                        xmit_scale = 1
                        print("[row" + str(csv_row_num) + "] Warning: no xmit_scale specified. Defaulting to 1")
                    # Error check function parameters
                    try:
                        assert(arg_name != "" and arg_type != "")
                    except:
                        print("[row " + str(csv_row_num) + "] " + "Error: function argument information cannot be blank\n")

                    # Append a tuple to that command's list
                    cmd_args[packet_type].append( (arg_name, arg_type, xmit_scale) )
                
                csv_row_num += 1

            # for line
        # with open
    except:
        print("Error: could not read template file. Exiting program...")
        return

    """
    Generate the s2_command() function, which packs commands and their function arguments
    from the gui to be sent to the board over serial
    """

    # Generate s2_command() documentation
    s2_command_str = "\t\"\"\"\n\tEncodes command info and arguments with COBS and transmits them over serial\n\t@params\n" \
        + "\t\tser (pyserial object)  - serial obejct to write to\n" \
        + "\t\tcmd_info (dict)        - dictionary with the following key value pairs:\n" \
        + "\t\t\t\"function_name\" : function name (string)\n" \
        + "\t\t\t\"target_board_addr\" : address of board to send command to (integer)\n" \
        + "\t\t\t\"timestamp\" : time the command was sent (integer)\n" \
        + "\t\t\t\"args\" : list of arguments to send to the function (list). Size of all arguments combined cannot exceed 242 bytes.\n" \
        + "\t\"\"\"\n"

    s2_command_str += "\tdef s2_command(self, ser, cmd_info):\n"
    s2_command_str += "\t\t# Check that it's a valid function\n" \
        + "\t\tif (cmd_info[\"function_name\"] not in self.cmd_names_dict.keys()):" \
        + "\n\t\t\tprint(cmd_info[\"function_name\"] + \" is not a valid function name. No command was sent.\")\n\t\t\treturn\n\n"
    s2_command_str += "\t\t# Initialize empty packet\n\t\tpacket = [0]*12 # Header is 12 bytes, will add bytes to fit function arguments\n" \
        + "\n\t\t# Fill first 12 bytes of packet with CLB packet header information\n" \
        + "\t\tpacket[0] = self.cmd_names_dict[cmd_info[\"function_name\"]]\t# packet_type\n" \
        + "\t\tpacket[1] = 0\t# ground computer addr\n" \
        + "\t\tpacket[2] = cmd_info[\"target_board_addr\"]\t# target_addr\n" \
        + "\t\tpacket[3] = 1\t# priority\n" \
        + "\t\tpacket[4] = 1\t# num_packets\n" \
        + "\t\tpacket[5] = 1\t# do_cobbs\n" \
        + "\t\tpacket[6] = 0\t# checksum\n" \
        + "\t\tpacket[7] = 0\t# checksum\n" \
        + "\t\tpacket[8] = (cmd_info[\"timestamp\"] >> 0) & 0xFF\t# timestamp\n" \
        + "\t\tpacket[9] = (cmd_info[\"timestamp\"] >> 8) & 0xFF\t# timestamp\n" \
        + "\t\tpacket[10] = (cmd_info[\"timestamp\"] >> 16) & 0xFF\t# timestamp\n" \
        + "\t\tpacket[11] = (cmd_info[\"timestamp\"] >> 24) & 0xFF\t# timestamp\n" \
        + "\n"
        
    #TODO: how to determine priority and checksum

    s2_command_str += "\t\t# Stuff packet with the function arguments according to the packet_type ID\n\t\tcommand_id = self.cmd_names_dict[cmd_info[\"function_name\"]]\n"

    # Create an if block for each command
    first_if_block = True
    for (packet_type, arg_list) in cmd_args.items():
        s2_command_str += "\t\t# " + cmd_id_to_name[packet_type] + "()\n"
        if (first_if_block):
            s2_command_str += "\t\tif "
            first_if_block = False
        else:
            s2_command_str += "\t\telif "
        s2_command_str += "(command_id == " + str(packet_type) + "):\n"

        if len(arg_list) == 0:
            s2_command_str += "\t\t\tpass  # No function arguments\n"
        else:
            # Iterate through the command's arguments and generate python code to pack them
            #packet_index = 11  # Start right after the CLB header  # removed because command packets are variable length now
            for arg_num, (arg_name, arg_type, xmit_scale) in enumerate(cmd_args[packet_type]):
                byte_length = byte_info.type_byte_lengths[arg_type]

                s2_command_str += "\t\t\t# " + arg_name + "\n"
                for b in range(byte_length):
                    s2_command_str += "\t\t\tpacket.append((int(cmd_info[\"args\"][" + str(arg_num) + "]*" \
                        + str(xmit_scale) + ") >> " + str(8*b) + ") & 0xFF)\n"
                    #packet_index += 1  # removed because command packets are variable length now

    s2_command_str += "\n\t\t# Encode the packet with COBS\n\t\tstuff_array(packet)\n"
    s2_command_str += "\n\t\t# Write the bytes to serial\n\t\tser.write(bytes(packet))\n"

    """
    Generate the function used to encode the packet with COBS
    (copied from EC3 gui)
    """
    stuff_array_str = "\"\"\"\nTakes in a byte packet and return a COBS encoded version\nNote: this was copied directly from the EC3 gui code\n" \
        + "@params\n" \
        + "\tarr (integer array)  - Byte packet to be COBS encoded\n" \
        + "\tseparator (integer)  - Packet delimiter. Should be using 0, but has the option to use any number\n" \
        + "\"\"\"\n"
    stuff_array_str += "def stuff_array(arr, separator=0):\n" \
        + "\tarr.append(0)\n" \
        + "\tarr.insert(0, 0)\n" \
        + "\tfirst_sep = 1\n" \
        + "\tfor x in arr[1:]:\n" \
        + "\t\tif x == separator:\n" \
        + "\t\t\tbreak\n" \
        + "\t\tfirst_sep += 1\n" \
        + "\tindex = 1\n" \
        + "\twhile(index < len(arr)-1):\n" \
        + "\t\tif(arr[index] == separator):\n" \
        + "\t\t\toffset = 1\n" \
        + "\t\t\twhile(arr[index+offset] != separator):\n" \
        + "\t\t\t\toffset += 1\n" \
        + "\t\t\tarr[index] = offset\n" \
        + "\t\t\tindex += offset\n" \
        + "\t\telse:\n" \
        + "\t\t\tindex += 1\n" \
        + "\tarr[0] = first_sep\n" \
        + "\treturn arr\n"

    """
    Generate the dict mapping command id/packet_type to that function's parameters
    """
    cmd_args_dict_str = "\t\t# A dictionary mapping packet_type (command ID) to a list of function argument information.\n" \
        + "\t\t# The nth tuple in each list corresponds to the nth argument for that command's function,\n" \
        + "\t\t# in the order (arg_name, arg_type, xmit_scale)\n"
    cmd_args_dict_str += "\t\tself.cmd_args_dict = {\n"

    # This part is functionaly the same as doing 'gui_dict_str += str(cmd_args)',
    # but it formats each key-value pair onto its own line
    for packet_type, arg_info in cmd_args.items():
        cmd_args_dict_str += "\t\t\t" + str(packet_type) + "\t:\t" + str(arg_info) + ",\n"
    cmd_args_dict_str = cmd_args_dict_str[0:len(cmd_args_dict_str)-2] + "\n"  # Cut off the last comma
    cmd_args_dict_str += "\t\t}\n"

    """
    Generate the dict mapping function name to id/packet_type, using the {packet_type : function_name} dictionary used by this file
    """
    cmd_names_dict_str = "\t\t# A dictionary mapping command name to packet_type (command ID)\n" \
        + "\t\tself.cmd_names_dict = {\n"
    
    for packet_type, function_name in cmd_id_to_name.items():
        cmd_names_dict_str += "\t\t\t\"" + function_name + "\"\t:\t" + str(packet_type) + ",\n"
    cmd_names_dict_str = cmd_names_dict_str[0:len(cmd_names_dict_str)-2] + "\n" # Cut off the last comma
    cmd_names_dict_str += "\t\t}\n"

    """
    Write all contents to the _s2InterfaceAutogen.py file
    """
    with open(filepath + "_s2InterfaceAutogen.py", "w+") as s2_auto:
        s2_auto.write(begin_autogen_tag + "\n### _s2InterfaceAutogen.py\n" + autogen_label + "\n\n" \
            + "import serial\n\nclass _S2_InterfaceAutogen:\n\tdef __init__(self):\n" \
            + cmd_names_dict_str + "\n" \
            + cmd_args_dict_str + "\n" \
            + s2_command_str + "\n" \
            + stuff_array_str + "\n")
        print("Created/updated " + filepath + "_s2InterfaceAutogen.py")


if __name__ == '__main__':
    main()
